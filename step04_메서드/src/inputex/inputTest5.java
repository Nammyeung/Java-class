package inputex;
//printf 출력
public class inputTest5 {

	public static void main(String[] args) {
		
		int eno=101;
		String ename = "홍길동";
		char dept = 'A'; // char 자료형 - 문자, 소문자, 특수문자, 한글, 기호, 한문, 기타 언어 / ASCII코드 1byte 사용 가 - 2byte사용 / 유니코드 2~3byte사용 / 배열을 선언해서 대입
		double score = 85.9;
		
		System.out.printf("사원번호 : %d\n", eno);
		System.out.printf("사원이름 : %s\n", ename);
		System.out.printf("부서코드 : %c\n", dept);
		System.out.printf("입사성적 : %f\n", score); // 부동소수점수 floating point : 
		
		System.out.print("test\r"); // carriage return의 경우에도 줄바꿈 기능이 나타난다.
		System.out.print("1004");
	}

}

/* 부동소수점 수 - 실수의 표현 방식
 * 
 */
/*
 * 컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡합니다.
 * 
 * 왜냐하면, 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표현해야 하기 때문입니다.
 * 
 * 따라서 실수를 표현하기 위한 다양한 방법들이 연구되었으며, 현재에는 다음과 같은 방식이 사용되고 있습니다.
 * 
 * 
 * 
 * 1. 고정 소수점(fixed point) 방식
 * 
 * 2. 부동 소수점(floating point) 방식
 * 
 * 고정 소수점(fixed point) 방식 실수는 보통 정수부와 소수부로 나눌 수 있습니다.
 * 
 * 따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현하는 것입니다.
 * 
 * 
 * 
 * 32비트 실수를 고정 소수점 방식으로 표현하면 다음과 같습니다.
 * 
 * 2. 부동 소수점 (Floating Point)

부동의 부는 뜰 부자로 소수점이 이동 가능하다고 해서 붙여진 이름이다.

부동 소수점 방식에서는 수를 정수와 소수 부분으로 나누지 않고, 지수(exponent)와 가수(fraction) 부분으로 나눠서 표현한다.



IEEE에서는 이 부동 소수점에 대한 표준을 정해 명시하고 있다.

https://ko.wikipedia.org/wiki/IEEE_754



그 중 32비트 단정밀도는 부호부에 1비트, 지수부에 8비트, 가수부에 23비트를 할당하는 표현 방식을 말하며, 반드시 구현하도록 권장된다. 많은 프로그래밍 언어의 4바이트 float 형식이 이 32비트 단정밀도를 따르고 있다.

그 외에 1, 11, 52 비트로 표현하는 64비트 배정밀도와 1, 15, 112 비트로 표현하는 128비트 4배정밀도가 있다.



예를 들어 -142.5625 를 32비트 단정밀도로 표현한다면



1. 부호부를 1로 지정한다 (음수 1, 양수 0)

2. 표현하고자 하는 수의 절댓값을 이진법으로 나타낸다. (142.5625 = 10001110.1001)

3. 소수점을 이동시켜 소수점 왼쪽에 1이 하나만 남도록 한다. (10001110.1001=1.00011101001×2^7) 

4. 소수점을 제거하고 가수부의 비트 수에 맞춰 부족한 만큼을 0으로 채우면 이게 가수부가 된다. (10001110100100000000000)

5. 지수는 7이므로 Bias(32비트 단정밀도에서는 127)를 더한 134을 이진법으로 표현하면 이것이 지수부가 된다 (10000110)

6. 결론적으로 -142.0625를 32비트 부동소수점으로 표현하면, 1 10000110 10001110100100000000000 이 된다.



5번에서의 Bias란 부호부를 가지지 않는 지수부가 음수가 되지 않도록 보정해주는 값을 말한다. 2^(n-1)-1 



부동 소수점 방식은 고정 소수점 방식에 비해 더 다양한 범위의 숫자를 표현할 수 있다는 장점이 있지만, 여전히 정밀도 문제가 존재하기 때문에 컴퓨터 상에서 실수를 다룰 때에는 연산이 언제나 오차를 가질 수 있다는 것을 유의하자.

 

일반적으로 언어들은 다양한 정밀도의 실수형을 제공하고 있으며, 경우에 맞게 적절한 정밀도의 자료형을 사용해야한다.



출처: https://hoodymong.tistory.com/50 [3초 2분 1년]
 */

 