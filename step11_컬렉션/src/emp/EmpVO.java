package emp;
//시작을 할 때는 vo를 만들고 시작
//vo(value object), entity, DTO(data transfer object), bean
//			: 데이터를 하나로 묶어서 전송할 목적으로 만든 클래스
public class EmpVO {
	private String name;
	private String dept;
	private int salary;
	public EmpVO() {
		super();
		// TODO Auto-generated constructor stub
	}
	public EmpVO(String name, String dept, int salary) {
		super();
		this.name = name;
		this.dept = dept;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDept() {
		return dept;
	}
	public void setDept(String dept) {
		this.dept = dept;
	}
	public int getSalary() {
		return salary;
	}
	public void setSalary(int salary) {
		this.salary = salary;
	}
		
}

// 생성자 & getter, setter => 데이터 베이스 구조
// 데이터베이스의 기본 원리 : table
// 엔티티 vs 값 객체
// [변수][][][][][][][]
// [][][][][][][][][]
/* 자바 웹 개발 워크북 - 값 객체(Value Object), 
 * 
 * 객체 지향 프로그래밍에서는 관련된 속성과 메서드를 객체로 표현한다. 예를 들어, 어플리케이션 상에서 사람은 객체가 될 수 있다. 사람은 이름, 이메일, 비밀번호 등 많은 속성을 지닌다. 
 * 데이터베이스에서는 이 사람을 id 로 식별한다. 이는 사람이 자신의 이름, 이메일, 비밀번호를 바꾸더라도 id 가 바뀌지 않으면 같은 사람임을 의미한다. 
 * 이렇게 속성이 바뀌더라도 여전히 같은 것으로 인식되는 객체를 엔티티라고 한다. 엔티티는 속성이 바뀔 수 있기 때문에 가변(mutable) 객체다. 엔티티의 정체성은 id 로 표현된다.

우리 어플리케이션이 사람의 현재 위치를 기록할 수 있다고 상상해보자. 그 사람이 성공적으로 인터넷에 연결하고 우리 어플리케이션에 인증을 하면 새로운 위치 객체가 생성된다. 
위치 객체는 위도와 경도 값을 가진다. 우리는 위치 객체가 어떤 위치 정보를 담고 있는지에만 관심이 있기 때문에 위치 객체는 값 객체가 된다.

어떤 사람의 위치가 바뀌었을 때 우리는 기존의 위치 객체를 갱신하지 않는다. 단순히 새로운 위치 객체를 생성한다. 
위치 객체는 생성된 이후로 소멸될 때까지 자신의 속성을 변경하지 않는다. 객체의 속성이 바뀔 수 없을 때, 그 객체를 불변(immutable) 객체라고 한다.

또한 값 객체는 식별자에 의해 같음(equality)이 결정되지 않는다. 예를 들어 당신이 같은 위도와 경도를 가진 위치 객체를 두 개 생성했다면 그 두 객체는 같은 객체이다. 
반면에 사람 객체는 id 라는 고유한 식별자로 같음을 판단한다. 같은 이름을 가진 두 개의 사람 객체가 있다고 해도 두 객체는 같지 않을 수 있다.

어떻게 값 객체를 식별할까?
이제 우리는 어떤 객체가 id 로 식별된다면 엔티티로, 그렇지 않다면 값 객체라고 구분할 수 있다. 엔티티의 속성은 바뀔 수 있다. 하지만 엔티티는 고유한 식별자로 표현되기 때문에 우리 시스템 상에서 같은 객체로 인식된다. 
반면 값 객체는 갖고 있는 값으로표현되는 객체이다. 한번 생성되면 그 값을 바꿀 수 없으며, 우리는 그것이 어떤 개체인지 신경쓰지 않는다.

언제 엔티티를 쓰고, 값 객체를 써야할지 어떻게 알 수 있을까? 그것은 어플리케이션의 상황에 따라 결정된다. 처음 예시로 돌아가보자. 우리 어플리케이션은 더이상 단순한 소셜 서비스가 아니다. 포스퀘어와 동일 다고 가정해보자. 
모든 위치 객체는 고유한 식별자를 지닌다. 많은 사람들이 같은 위치에서 체크인을 할 수 있기 때문이다. 이제 위치 객체는 더이상 값 객체가 아닌 엔티티가 된다.

예제를 바꿔보자. 우리가 파워 플랜트의 소유자라고 상상해보라. 파워 플랜트는 철책(securify fence) 주변에서 일어나는 모든 활동을 기록한다. 감시의 목적으로 철책 주변의 많은 위치에서 활동이 기록된다. 
이 때 우리는 특정 위치에서 일어나는 활동에 대해 관심이 있기 때문에 철책 주변의 위치는 엔티티가 된다. 수상한 사람이 우리가 감시하는 위치로 들어오게 되면 그 사건은 데이터베이스에 저장된다. 이 예제에서 사람은 값 객체이다. 
우리는 감시중인 위치에 들어 온 사람이 어떤 사람인지 관심이 없기 때문이다. 단지 그 사람이 감시중인 위치에 걸려들었을 뿐이다.

위의 예제와 보았듯 어떤 객체가 엔티티인지 값 객체인지는 여러분의 어플리케이션이 그것을 어떻게 사용할 것인지에 달려있다. 일반적으로 위치, 날짜, 숫자, 금액은 값 객체인 경우가 많다. 
그리고 사람, 제품, 파일, 판매는 엔티티인 경우가 대부분이다.

 * 메인에서 객체 생성 UserProc은 아무것도 없고 User 변수, 생성자 => vo 혹은 entity
 * 
 */
